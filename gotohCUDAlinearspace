#include <iostream>
#include <fstream> 
#include <vector>
#include <string>
#include <algorithm>
#include <limits>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <functional>
#include "gotohCUDA.h"
#include "types.h"

#include <cuda_runtime.h>
#include <cuda.h>
using namespace std;

#define IDX(i, j, w) ((i) * (w) + (j))


/*

//this function is a function to read fasta file, i used GPT to write it
string fastaReader(const string &path) {
    ifstream in(path);
    if (!in) throw runtime_error("Cannot open FASTA file: " + path);
    string line, seq;
    while (getline(in, line)) {
        if (line.empty() || line[0] == '>') continue;
        seq += line;
    }
    return seq;
}

*/

//For comparing results 
struct AlignmentResult {
    std::string A_aligned;
    std::string B_aligned;
    int score;

    AlignmentResult(const std::string& a, const std::string& b, int s)
        : A_aligned(a), B_aligned(b), score(s) {}

};

// for transferring variables between function calls
struct AlignmentMatrices {
    std::vector<int> M, I, D;
    std::vector<int> traceM, traceI, traceD;
    int m, n, width;
};


//Computes one anti-diagonal
__global__ void gotoh_linear_space_kernel(int diag, const char* A, const char* B,
                                          int m, int n, const int* submat,
                                          int gap_open, int gap_extend,
                                          int* prevM, int* prevI, int* prevD,
                                          int* currM, int* currI, int* currD) {
    int thread_id = blockIdx.x * blockDim.x + threadIdx.x;
    int i = max(1, diag - n) + thread_id;
    int j = diag - i;

    if (i > m || j < 1 || j > n) return;

    int index = thread_id; // current position in anti-diagonal

    int sub_score = submat[(int)A[i - 1] * 128 + (int)B[j - 1]];

    int open_I = prevM[index] - (gap_open + gap_extend);
    int extend_I = prevI[index] - gap_extend;
    currI[index] = max(open_I, extend_I);

    int open_D = (index > 0) ? currM[index - 1] - (gap_open + gap_extend) : INT_MIN / 2;
    int extend_D = (index > 0) ? currD[index - 1] - gap_extend : INT_MIN / 2;
    currD[index] = max(open_D, extend_D);

    int match = (index > 0) ? prevM[index - 1] + sub_score : INT_MIN / 2;
    currM[index] = max(match, max(currI[index], currD[index]));
}


AlignmentMatrices gotoch_align_cuda(const string&A, const string &B, int openGap, int extendGap, const std::vector<std::vector<int>> &submat) {
    
    const int THREADS_PER_BLOCK = 128;
    const int NEG_INF = numeric_limits<int>::min()/2;
    
    char *d_A, *d_B;
    int *d_M, *d_I, *d_D, *d_submat;
    int *d_traceM, *d_traceI, *d_traceD;

    

    
    const int m = A.size();
    const int n = B.size();
    const int width = n + 1;
    const int size = (m + 1) * (n + 1);

    //Flatten substition matrix (code received from CHATGPT)
    std::vector<int> flatSubmat(128 * 128, 0);
    for (int i = 0; i < 128; ++i)
        for (int j = 0; j < 128; ++j)
            flatSubmat[i * 128 + j] = submat[i][j];

    
    
    /*
    //here we are allocating host flattened matrices (HOST)
    vector<int> hM(size, NEG_INF);
    vector<int> hI(size, NEG_INF);
    vector<int> hD(size, NEG_INF);
    hM[0] = hI[0] = hD[0] = 0;

    for (int i = 1; i <= m; i++) {
        hI[i * width] =  -(openGap +(i-1)*extendGap);
    }
    for (int j = 1; j <= n; j++) {
        hD[j] = -(openGap + (j-1)*extendGap);
    }


    vector<int> hTraceM(size);
    vector<int> hTraceI(size);
    vector<int> hTraceD(size);



    */
    // Allocate to host
    cudaMalloc(&d_A, m*sizeof(char));
    cudaMalloc(&d_B, n*sizeof(char));
    cudaMemcpy(d_A, A.c_str(), m, cudaMemcpyHostToDevice);
    cudaMemcpy(d_B, B.c_str(), n, cudaMemcpyHostToDevice);

    int max_length = min(n, m) + 1;

    cudaMalloc(&d_prevM, max_length * sizeof(int));
    cudaMalloc(&d_currM, max_length * sizeof(int));

    cudaMalloc(&d_prevI, max_length * sizeof(int));
    cudaMalloc(&d_currI, max_length * sizeof(int));

    cudaMalloc(&d_prevD, max_length * sizeof(int));
    cudaMalloc(&d_currD, max_length * sizeof(int));'

    cudaMemcpy(d_prevM, prev_M.data(), max_length * sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(d_prevD, prev_D.data(), max_length * sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(d_prevI, prev_I.data(), max_length * sizeof(int), cudaMemcpyHostToDevice);

    /*
    cudaMalloc(&d_M, size * sizeof(int));
    cudaMalloc(&d_I, size * sizeof(int));
    cudaMalloc(&d_D, size * sizeof(int));
    cudaMemcpy(d_M, hM.data(), size * sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(d_I, hI.data(), size * sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(d_D, hD.data(), size * sizeof(int), cudaMemcpyHostToDevice);
    */

    cudaMalloc(&d_submat, 128 * 128 * sizeof(int));
    cudaMemcpy(d_submat, flatSubmat.data(), 128 * 128 * sizeof(int), cudaMemcpyHostToDevice); 


    //traceback matrices
    cudaMalloc(&d_traceM, size * sizeof(int));
    cudaMalloc(&d_traceI, size * sizeof(int));
    cudaMalloc(&d_traceD, size * sizeof(int));

    //Compute on GPU, we launch kernels for each diagonal
    for (int diag = 2; diag <= m + n; ++diag){
        int i_min = max(1, diag - n);
        int i_max = min(m, diag - 1);
        int total = i_max - i_min + 1;
        if (total <= 0) continue;

        int blocks = (total + THREADS_PER_BLOCK - 1) / THREADS_PER_BLOCK;
    
        gotohAUX2<<<blocks, THREADS_PER_BLOCK>>>(diag, m, n, d_A, d_B,
                                         openGap, extendGap, d_submat,
                                         d_M, d_I, d_D,
                                         d_traceM, d_traceI, d_traceD);
    
        cudaError_t err = cudaGetLastError();
        if (err != cudaSuccess) {
            std::cerr << "CUDA kernel launch error at diag " << diag << ": " << cudaGetErrorString(err) << std::endl;
            exit(1);
        }

        cudaDeviceSynchronize();


    }

    //Results back to host
    cudaMemcpy(hM.data(), d_M, size * sizeof(int), cudaMemcpyDeviceToHost);
    cudaMemcpy(hI.data(), d_I, size * sizeof(int), cudaMemcpyDeviceToHost);
    cudaMemcpy(hD.data(), d_D, size * sizeof(int), cudaMemcpyDeviceToHost);
    cudaMemcpy(hTraceM.data(), d_traceM, size * sizeof(int), cudaMemcpyDeviceToHost);
    cudaMemcpy(hTraceI.data(), d_traceI, size * sizeof(int), cudaMemcpyDeviceToHost);
    cudaMemcpy(hTraceD.data(), d_traceD, size * sizeof(int), cudaMemcpyDeviceToHost);




    //Free CUDA memory
    cudaFree(d_A);
    cudaFree(d_B);
    cudaFree(d_M);
    cudaFree(d_I);
    cudaFree(d_D);
    cudaFree(d_traceM);
    cudaFree(d_traceI);
    cudaFree(d_traceD);
    cudaFree(d_submat);

    return {
        std::move(hM), std::move(hI), std::move(hD),
        std::move(hTraceM), std::move(hTraceI), std::move(hTraceD),
        m, n, width
    };

}

AlignmentResult gotoch_align_result(const std::string& A, const std::string& B,
                                const std::vector<int>& hM,
                                const std::vector<int>& hI,
                                const std::vector<int>& hD,
                                const std::vector<int>& hTraceM,
                                const std::vector<int>& hTraceI,
                                const std::vector<int>& hTraceD,
                                int m, int n, int width) {
    auto IDX = [width](int i, int j) { return i * width + j; };


    int end = IDX(m, n, width);
    int score_D = hD[end];
    int score_M = hM[end];
    int score_I = hI[end];
    int score;
    char chosen;

    // compare values of different matrices

    if (score_M >= score_I && score_M >= score_D) {
        score = score_M;
        chosen = 'M';
    } else if (score_D >= score_I) {
        score = score_D;
        chosen = 'D';
    }else {
        score = score_I;
        chosen = 'I';
    }
    
    char current = chosen;

    std::string A_aligned, B_aligned;

    // traceback logic as seen in the CPU implementation
    int i = m, j = n;

    while (i > 0 || j > 0) {
        if (current == 'M') {
            if (i == 0) {
                current = 'D';
                continue;
            }
            if (j == 0) {
                current = 'I';
                continue;
            }
            int trace = hTraceM[IDX(i, j, width)];
            if (trace == 0) { // from M[i-1][j-1]
                A_aligned += A[i - 1];
                B_aligned += B[j - 1];
                i--; j--;
            } else if (trace == 1) {
                current = 'I';
            } else {
                current = 'D';
            }
        } else if (current == 'I') {
            if (i == 0) {
                current = 'D';
                continue;
            }
            A_aligned += A[i - 1];
            B_aligned += '-';
            if (hTraceI[IDX(i, j, width)] == 0) {
                current = 'M';
            } else {
                current = 'I';
            }
            i--;
        } else { // current == 'D'
            if (j == 0) {
                current = 'I';
                continue;
            }
            B_aligned += B[j - 1];
            A_aligned += '-';
            if (hTraceD[IDX(i, j, width)] == 0) {
                current = 'M';
            } else {
                current = 'D';
            }
            j--;
        }
    }

    //we reverse so that the strings we get are from left to right 
    std::reverse(A_aligned.begin(), A_aligned.end());
    std::reverse(B_aligned.begin(), B_aligned.end());

    return AlignmentResult(A_aligned, B_aligned, score);
}

// computes the alignment score for a pair of sequences, where the score depends on how we give weights to different operations
// so open gap, extend gap, match, and mismatch
// the function calculates, in milliseconds, how long finding the alignment takes with the GPU implementation
ScoreTime alignGPU(const std::string& A, const std::string& B,
            const int openGap, const int extendGap,
            const int match, const int mismatch) {

    std::string amino_acids = "ARNDCQEGHILKMFPSTWYVBZXOUJ";

    vector<vector<int>> submat(128, vector<int>(128, mismatch)); 
    for (char c : amino_acids) submat[c][c] = match;
    //for (char c : {'A','C','G','T'}) submat[c][c] = match; # DNA

    cudaEvent_t gpu_start, gpu_end;
    cudaEventCreate(&gpu_start);
    cudaEventCreate(&gpu_end);

    cudaEventRecord(gpu_start); // start time
    // get result
    AlignmentMatrices ms = gotoch_align_cuda(A, B, openGap, extendGap, submat);
    AlignmentResult result = gotoch_align_result(A, B, ms.M, ms.I, ms.D, ms.traceM, ms.traceI, ms.traceD, ms.m, ms.n, ms.width);
    cudaEventRecord(gpu_end); // end time
    cudaEventSynchronize(gpu_end);

    float gpu_time_ms;
    cudaEventElapsedTime(&gpu_time_ms, gpu_start, gpu_end);
    
    // return object with alignment score and time taken
    ScoreTime res = ScoreTime(result.score,gpu_time_ms);

    return res;
}



/*


int main() {



    //testing code with input strings
    std::string A = fastaReader("seqA.fasta");
    std::string B = fastaReader("seqB.fasta");

    // parameters for scoring alignment
    int openGap = 10;
    int extendGap = 1;
    int match = 3;
    int mismatch = -1;

    // submatrix initialization
    vector<vector<int>> submat(128, vector<int>(128, mismatch));
    for (char c : {'A','C','G','T'}) submat[c][c] = match;

    // timing
    cudaEvent_t gpu_start, gpu_end;
    cudaEventCreate(&gpu_start);
    cudaEventCreate(&gpu_end);

    cudaEventRecord(gpu_start);
    AlignmentMatrices ms = gotoch_align_cuda(A, B, openGap, extendGap, submat);
    AlignmentResult result = gotoch_align_result(A, B, ms.M, ms.I, ms.D, ms.traceM, ms.traceI, ms.traceD, ms.m, ms.n, ms.width);
    cudaEventRecord(gpu_end);
    cudaEventSynchronize(gpu_end);

    float gpu_time_ms;
    cudaEventElapsedTime(&gpu_time_ms, gpu_start, gpu_end);
    std::cout << "GPU Time: " << gpu_time_ms / 1000.0 << " s\n";

    // get results (body of code)
   
    std::cout << "Aligned A: " << result.A_aligned << "\n";
    std::cout << "Aligned B: " << result.B_aligned << "\n";
    std::cout << "Alignment score: " << result.score << "\n";


    return 0;
}

    
*/


  

    

